{-Agda
module plfa.part1.Connectives where
Agda-}

-- Arend uses a "propositions as some types" aproach to encode logic. There is as a special universe '\Prop'
-- of types that has at most one element. Empty types correspond to false propositions,
-- one element types correspond to true propositions.
-- https://arend-lang.github.io/documentation/language-reference/expressions/universes
-- https://ncatlab.org/nlab/show/propositions+as+types#PropositionsAsSomeTypes

{-Agda
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl)
open Eq.≡-Reasoning
open import Data.Nat using (ℕ)
open import Function using (_∘_)
open import plfa.part1.Isomorphism using (_≃_; _≲_; extensionality)
open plfa.part1.Isomorphism.≃-Reasoning
Agda-}

\import Paths (==<, >==, qed)
\import Function (o)
\import util.Equiv (=~, =~-Reasoning)
\open =~-Reasoning
\import Equiv (>->)
\import util.Function (extensionality)

{-Agda
data _×_ (A B : Set) : Set where

  ⟨_,_⟩ :
      A
    → B
      -----
    → A × B
Agda-}

\data \infixr 2 x (A B : \Type)
  | prod A B

-- Conjunction is a product over '\Prop'

\func \infixr 2 && (A B : \Prop) : \Prop => A x B

{-Agda
proj₁ : ∀ {A B : Set}
  → A × B
    -----
  → A
proj₁ ⟨ x , y ⟩ = x

proj₂ : ∀ {A B : Set}
  → A × B
    -----
  → B
proj₂ ⟨ x , y ⟩ = y
Agda-}

\func proj1 {A B : \Type} (w : A x B) : A
  | prod a b => a

\func proj2 {A B : \Type} (w : A x B) : B
  | prod a b => b

{-Agda
η-× : ∀ {A B : Set} (w : A × B) → ⟨ proj₁ w , proj₂ w ⟩ ≡ w
η-× ⟨ x , y ⟩ = refl
Agda-}

\func eta-x {A B : \Type} (w : A x B) : prod (proj1 w) (proj2 w) = w
  | prod a b => idp

{-Agda
record _×′_ (A B : Set) : Set where
  constructor ⟨_,_⟩′
  field
    proj₁′ : A
    proj₂′ : B
open _×′_
Agda-}

\record \infixr 2 x' (A B : \Type)
  | proj1' : A
  | proj2' : B

\func \infixr 2 prod' {A B : \Type} (a : A) (b : B) : A x' B \cowith
  | proj1' => a
  | proj2' => b

{-Agda
η-×′ : ∀ {A B : Set} (w : A ×′ B) → ⟨ proj₁′ w , proj₂′ w ⟩′ ≡ w
η-×′ w = refl
Agda-}

\func eta-&&' {A B : \Type} (w : A x' B) : w.proj1' prod' w.proj2' = w => idp