{-Agda
module plfa.part1.Connectives where
Agda-}

-- Arend uses a "propositions as some types" aproach to encode logic. There is as a special universe '\Prop'
-- of types that has at most one element. Empty types correspond to false propositions,
-- one element types correspond to true propositions.
-- https://arend-lang.github.io/documentation/language-reference/expressions/universes
-- https://ncatlab.org/nlab/show/propositions+as+types#PropositionsAsSomeTypes

{-Agda
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl)
open Eq.≡-Reasoning
open import Data.Nat using (ℕ)
open import Function using (_∘_)
open import plfa.part1.Isomorphism using (_≃_; _≲_; extensionality)
open plfa.part1.Isomorphism.≃-Reasoning
Agda-}

\import Paths (==<, >==, qed)
\import Function (o)
\import util.Equiv (=~, =~-Reasoning)
\open =~-Reasoning
\import Equiv (>->)
\import util.Function (extensionality)

{-Agda
data _×_ (A B : Set) : Set where

  ⟨_,_⟩ :
      A
    → B
      -----
    → A × B
Agda-}

\data \infixr 2 x (A B : \Type)
  | prod A B

-- Conjunction is a product over '\Prop'

\func \infixr 2 && (A B : \Prop) : \Prop => A x B

{-Agda
proj₁ : ∀ {A B : Set}
  → A × B
    -----
  → A
proj₁ ⟨ x , y ⟩ = x

proj₂ : ∀ {A B : Set}
  → A × B
    -----
  → B
proj₂ ⟨ x , y ⟩ = y
Agda-}

\func proj1 {A B : \Type} (w : A x B) : A
  | prod a b => a

\func proj2 {A B : \Type} (w : A x B) : B
  | prod a b => b

{-Agda
η-× : ∀ {A B : Set} (w : A × B) → ⟨ proj₁ w , proj₂ w ⟩ ≡ w
η-× ⟨ x , y ⟩ = refl
Agda-}

\func eta-x {A B : \Type} (w : A x B) : prod (proj1 w) (proj2 w) = w
  | prod a b => idp

{-Agda
record _×′_ (A B : Set) : Set where
  constructor ⟨_,_⟩′
  field
    proj₁′ : A
    proj₂′ : B
open _×′_
Agda-}

\record \infixr 2 x' (A B : \Type)
  | proj1' : A
  | proj2' : B

\func \infixr 2 prod' {A B : \Type} (a : A) (b : B) : A x' B \cowith
  | proj1' => a
  | proj2' => b

{-Agda
η-×′ : ∀ {A B : Set} (w : A ×′ B) → ⟨ proj₁′ w , proj₂′ w ⟩′ ≡ w
η-×′ w = refl
Agda-}

\func eta-&&' {A B : \Type} (w : A x' B) : w.proj1' prod' w.proj2' = w => idp

{-Agda
data Bool : Set where
  true  : Bool
  false : Bool

data Tri : Set where
  aa : Tri
  bb : Tri
  cc : Tri
Agda-}

\data Bool | true | false

\data Tri | aa | bb | cc

{-Agda
×-count : Bool × Tri → ℕ
×-count ⟨ true  , aa ⟩  =  1
×-count ⟨ true  , bb ⟩  =  2
×-count ⟨ true  , cc ⟩  =  3
×-count ⟨ false , aa ⟩  =  4
×-count ⟨ false , bb ⟩  =  5
×-count ⟨ false , cc ⟩  =  6
Agda-}

\func x-count (bt : Bool x Tri) : Nat
  | prod true aa => 1
  | prod true bb => 2
  | prod true cc => 3
  | prod false aa => 4
  | prod false bb => 5
  | prod false cc => 6

{-Agda
×-comm : ∀ {A B : Set} → A × B ≃ B × A
×-comm =
  record
    { to       =  λ{ ⟨ x , y ⟩ → ⟨ y , x ⟩ }
    ; from     =  λ{ ⟨ y , x ⟩ → ⟨ x , y ⟩ }
    ; from∘to  =  λ{ ⟨ x , y ⟩ → refl }
    ; to∘from  =  λ{ ⟨ y , x ⟩ → refl }
    }
Agda-}

\func x-comm {A B : \Type} : A x B =~ B x A \cowith
  | f (p : A x B) : B x A \with {
    | prod x y => prod y x
  }
  | ret (p : B x A) : A x B \with {
    | prod y x => prod x y
  }
  | ret_f (p : A x B) : ret (f p) = p \with {
    | prod x y => idp
  }
  | f_sec (p : B x A) : f (ret p) = p \with {
    | prod y x => idp
  }

-- (!) In Arend, we can prove that product is purely commutative (without isomorphism).
-- The proof uses builtin function `iso`, which basically states that isomorphism implies equality
-- (or, better read, equivalence implies identity). This is called the univalence principle.

\func x-comm' {A B : \Type} : A x B = B x A =>
  path (iso x-comm.f x-comm.ret x-comm.ret_f x-comm.f_sec)

-- The same using a library function `equiv=`

\import Equiv.Sigma (equiv=)

\func x-comm'' {A B : \Type} : A x B = B x A => equiv= x-comm

{-Agda
×-assoc : ∀ {A B C : Set} → (A × B) × C ≃ A × (B × C)
×-assoc =
  record
    { to      = λ{ ⟨ ⟨ x , y ⟩ , z ⟩ → ⟨ x , ⟨ y , z ⟩ ⟩ }
    ; from    = λ{ ⟨ x , ⟨ y , z ⟩ ⟩ → ⟨ ⟨ x , y ⟩ , z ⟩ }
    ; from∘to = λ{ ⟨ ⟨ x , y ⟩ , z ⟩ → refl }
    ; to∘from = λ{ ⟨ x , ⟨ y , z ⟩ ⟩ → refl }
    }
Agda-}

\func x-assoc {A B C : \Type} : (A x B) x C =~ A x (B x C) \cowith
  | f (p : (A x B) x C) : A x (B x C) \with {
    | prod (prod a b) c => prod a (prod b c)
  }
  | ret (p : A x (B x C)) : (A x B) x C \with {
    | prod a (prod b c) => prod (prod a b) c
  }
  | ret_f (p : (A x B) x C) : ret (f p) = p \with {
    | prod (prod a b) c => idp
  }
  | f_sec (p : A x (B x C)) : f (ret p) = p \with {
    | prod a (prod b c) => idp
  }

\func x-assoc' {A B C : \Type} : (A x B) x C = A x (B x C) => equiv= x-assoc