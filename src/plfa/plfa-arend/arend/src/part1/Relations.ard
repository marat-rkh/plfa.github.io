\import Paths (pmap)
\open Nat (+)
\import Arith.Nat (NatSemiring)
\open NatSemiring (+-comm)

{-Agda
data _≤_ : ℕ → ℕ → Set where

  z≤n : ∀ {n : ℕ}
      --------
    → zero ≤ n

  s≤s : ∀ {m n : ℕ}
    → m ≤ n
      -------------
    → suc m ≤ suc n
Agda-}

-- Note that each constructor has `m` and `n` as implicit parameters.

\data \infix 4 <= (m n : Nat) \with
  | 0, _ => z<=n
  | suc m, suc n => s<=s (m <= n)

{-Agda
_ : 2 ≤ 4
_ = s≤s (s≤s z≤n)
Agda-}

\func [2<=4] : 2 <= 4 => s<=s (s<=s z<=n)

{-Agda
_ : 2 ≤ 4
_ = s≤s {1} {3} (s≤s {0} {2} (z≤n {2}))
Agda-}

\func [2<=4]' : 2 <= 4 => s<=s {1} {3} (s<=s {0} {2} (z<=n {2}))

{-Agda
_ : 2 ≤ 4
_ = s≤s {m = 1} {n = 3} (s≤s {m = 0} {n = 2} (z≤n {n = 2}))
Agda-}

-- Arend doesn't have this.

{-Agda
_ : 2 ≤ 4
_ = s≤s {n = 3} (s≤s {n = 2} z≤n)
Agda-}

-- Arend doesn't have this.

{-Agda
+-identityʳ′ : ∀ {m : ℕ} → m + zero ≡ m
+-identityʳ′ = +-identityʳ _
Agda-}

\import part1.Induction (+-identity-left)

\func +-identity-left' {m : Nat} : 0 + m = m => +-identity-left _

{-Agda
infix 4 _≤_
Agda-}

-- As we have seen above, precedence is declared as a part of the data declaration in Arend.

{-Agda
inv-s≤s : ∀ {m n : ℕ}
  → suc m ≤ suc n
    -------------
  → m ≤ n
inv-s≤s (s≤s m≤n) = m≤n
Agda-}

\func inv-s<=s {m n : Nat} (p : suc m <= suc n) : m <= n \elim p
  | s<=s m<=n => m<=n

{-Agda
inv-z≤n : ∀ {m : ℕ}
  → m ≤ zero
    --------
  → m ≡ zero
inv-z≤n z≤n = refl
Agda-}

-- TODO Agda seems to be a bit smarter here.

\func inv-z<=n {m : Nat} (p : m <= 0) : m = 0 \elim m
  | 0 => idp

{-Agda
-- Your code goes here
Agda-}

-- Your code goes here

{-Agda
-- Your code goes here
Agda-}

-- Your code goes here

{-Agda
≤-refl : ∀ {n : ℕ}
    -----
  → n ≤ n
≤-refl {zero} = z≤n
≤-refl {suc n} = s≤s ≤-refl
Agda-}

\func <=-refl {n : Nat} : n <= n
  | {0} => z<=n
  | {suc n} => s<=s <=-refl

{-Agda
≤-trans : ∀ {m n p : ℕ}
  → m ≤ n
  → n ≤ p
    -----
  → m ≤ p
≤-trans z≤n       _          =  z≤n
≤-trans (s≤s m≤n) (s≤s n≤p)  =  s≤s (≤-trans m≤n n≤p)
Agda-}

-- TODO Agda can pattern match on constructors directly here, Arend cannot.
-- Moreover, this way of proving is refered as "immensely valuable, and one that we use often".

\func <=-trans {m n p : Nat} (m<=n : m <= n) (n<=p : n <= p) : m <= p
  | {0}, _, _ => z<=n
  | {suc m}, {suc n}, {suc p}, s<=s m<=n, s<=s n<=p => s<=s (<=-trans m<=n n<=p)

{-Agda
≤-trans′ : ∀ (m n p : ℕ)
  → m ≤ n
  → n ≤ p
    -----
  → m ≤ p
≤-trans′ zero    _       _       z≤n       _          =  z≤n
≤-trans′ (suc m) (suc n) (suc p) (s≤s m≤n) (s≤s n≤p)  =  s≤s (≤-trans′ m n p m≤n n≤p)
Agda-}

\func <=-trans' (m n p : Nat) (m<=n : m <= n) (n<=p : n <= p) : m <= p
  | 0 , _, _, _, _ => z<=n
  | suc m, suc n, suc p, s<=s m<=n, s<=s n<=p => s<=s (<=-trans m<=n n<=p)