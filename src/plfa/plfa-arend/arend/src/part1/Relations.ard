\import Paths (pmap)
\open Nat (+)
\import Arith.Nat (NatSemiring)
\open NatSemiring (+-comm)

{-Agda
data _≤_ : ℕ → ℕ → Set where

  z≤n : ∀ {n : ℕ}
      --------
    → zero ≤ n

  s≤s : ∀ {m n : ℕ}
    → m ≤ n
      -------------
    → suc m ≤ suc n
Agda-}

-- Note that each constructor has `m` and `n` as implicit parameters.

\data \infix 4 <= (m n : Nat) \with
  | 0, _ => z<=n
  | suc m, suc n => s<=s (m <= n)

{-Agda
_ : 2 ≤ 4
_ = s≤s (s≤s z≤n)
Agda-}

\func [2<=4] : 2 <= 4 => s<=s (s<=s z<=n)

{-Agda
_ : 2 ≤ 4
_ = s≤s {1} {3} (s≤s {0} {2} (z≤n {2}))
Agda-}

\func [2<=4]' : 2 <= 4 => s<=s {1} {3} (s<=s {0} {2} (z<=n {2}))

{-Agda
_ : 2 ≤ 4
_ = s≤s {m = 1} {n = 3} (s≤s {m = 0} {n = 2} (z≤n {n = 2}))
Agda-}

-- Arend doesn't have this.

{-Agda
_ : 2 ≤ 4
_ = s≤s {n = 3} (s≤s {n = 2} z≤n)
Agda-}

-- Arend doesn't have this.

{-Agda
+-identityʳ′ : ∀ {m : ℕ} → m + zero ≡ m
+-identityʳ′ = +-identityʳ _
Agda-}

\import part1.Induction (+-identity-left)

\func +-identity-left' {m : Nat} : 0 + m = m => +-identity-left _

{-Agda
infix 4 _≤_
Agda-}

-- As we have seen above, precedence is declared as a part of the data declaration in Arend.

{-Agda
inv-s≤s : ∀ {m n : ℕ}
  → suc m ≤ suc n
    -------------
  → m ≤ n
inv-s≤s (s≤s m≤n) = m≤n
Agda-}

\func inv-s<=s {m n : Nat} (p : suc m <= suc n) : m <= n \elim p
  | s<=s m<=n => m<=n

{-Agda
inv-z≤n : ∀ {m : ℕ}
  → m ≤ zero
    --------
  → m ≡ zero
inv-z≤n z≤n = refl
Agda-}

-- TODO Agda seems to be a bit smarter here.

\func inv-z<=n {m : Nat} (p : m <= 0) : m = 0 \elim m
  | 0 => idp

{-Agda
-- Your code goes here
Agda-}

-- Your code goes here

{-Agda
-- Your code goes here
Agda-}

-- Your code goes here

{-Agda
≤-refl : ∀ {n : ℕ}
    -----
  → n ≤ n
≤-refl {zero} = z≤n
≤-refl {suc n} = s≤s ≤-refl
Agda-}

\func <=-refl {n : Nat} : n <= n
  | {0} => z<=n
  | {suc n} => s<=s <=-refl

{-Agda
≤-trans : ∀ {m n p : ℕ}
  → m ≤ n
  → n ≤ p
    -----
  → m ≤ p
≤-trans z≤n       _          =  z≤n
≤-trans (s≤s m≤n) (s≤s n≤p)  =  s≤s (≤-trans m≤n n≤p)
Agda-}

-- TODO Agda can pattern match on constructors directly here, Arend cannot.
-- See: https://github.com/JetBrains/Arend/issues/286

\func <=-trans {m n p : Nat} (m<=n : m <= n) (n<=p : n <= p) : m <= p
  | {0}, _, _ => z<=n
  | {suc m}, {suc n}, {suc p}, s<=s m<=n, s<=s n<=p => s<=s (<=-trans m<=n n<=p)

{-Agda
≤-trans′ : ∀ (m n p : ℕ)
  → m ≤ n
  → n ≤ p
    -----
  → m ≤ p
≤-trans′ zero    _       _       z≤n       _          =  z≤n
≤-trans′ (suc m) (suc n) (suc p) (s≤s m≤n) (s≤s n≤p)  =  s≤s (≤-trans′ m n p m≤n n≤p)
Agda-}

\func <=-trans' (m n p : Nat) (m<=n : m <= n) (n<=p : n <= p) : m <= p
  | 0 , _, _, _, _ => z<=n
  | suc m, suc n, suc p, s<=s m<=n, s<=s n<=p => s<=s (<=-trans m<=n n<=p)

{-Agda
≤-antisym : ∀ {m n : ℕ}
  → m ≤ n
  → n ≤ m
    -----
  → m ≡ n
≤-antisym z≤n       z≤n        =  refl
≤-antisym (s≤s m≤n) (s≤s n≤m)  =  cong suc (≤-antisym m≤n n≤m)
Agda-}

\func <=-antisym {m n : Nat} (m<=n : m <= n) (n<=m : n <= m) : m = n
  | {0}, {0}, z<=n, z<=n => idp
  | {suc n}, {suc m}, s<=s m<=n, s<=s n<=m => pmap suc (<=-antisym m<=n n<=m)

{-Agda
-- Your code goes here
Agda-}

-- Your code goes here

{-Agda
data Total (m n : ℕ) : Set where

  forward :
      m ≤ n
      ---------
    → Total m n

  flipped :
      n ≤ m
      ---------
    → Total m n
Agda-}

-- TODO It seems like Arend doesn't have a distinction between 'parameters' and 'indices'.
-- All data types are indexed (in Agda terms).

\data Total (m n : Nat)
  | forward (m <= n)
  | flipped (n <= m)

{-Agda
data Total′ : ℕ → ℕ → Set where

  forward′ : ∀ {m n : ℕ}
    → m ≤ n
      ----------
    → Total′ m n

  flipped′ : ∀ {m n : ℕ}
    → n ≤ m
      ----------
    → Total′ m n
Agda-}

-- Same in Arend.

{-Agda
≤-total : ∀ (m n : ℕ) → Total m n
≤-total zero    n                         =  forward z≤n
≤-total (suc m) zero                      =  flipped z≤n
≤-total (suc m) (suc n) with ≤-total m n
...                        | forward m≤n  =  forward (s≤s m≤n)
...                        | flipped n≤m  =  flipped (s≤s n≤m)
Agda-}

\func <=-total (m n : Nat) : Total m n
  | 0, n => forward z<=n
  | suc m, 0 => flipped z<=n
  | suc m, suc n => \case <=-total m n \with {
    | forward m<=n => forward (s<=s m<=n)
    | flipped n<=m => flipped (s<=s n<=m)
  }

{-Agda
≤-total′ : ∀ (m n : ℕ) → Total m n
≤-total′ zero    n        =  forward z≤n
≤-total′ (suc m) zero     =  flipped z≤n
≤-total′ (suc m) (suc n)  =  helper (≤-total′ m n)
  where
  helper : Total m n → Total (suc m) (suc n)
  helper (forward m≤n)  =  forward (s≤s m≤n)
  helper (flipped n≤m)  =  flipped (s≤s n≤m)
Agda-}

\func <=-total' (m n : Nat) : Total m n
  | 0, n => forward z<=n
  | suc m, 0 => flipped z<=n
  | suc m, suc n => helper (<=-total' m n)
  \where {
    \func helper {m n : Nat} (t : Total m n) : Total (suc m) (suc n) \elim t
      | forward m<=n => forward (s<=s m<=n)
      | flipped n<=m => flipped (s<=s n<=m)
  }

{-Agda
≤-total″ : ∀ (m n : ℕ) → Total m n
≤-total″ m       zero                      =  flipped z≤n
≤-total″ zero    (suc n)                   =  forward z≤n
≤-total″ (suc m) (suc n) with ≤-total″ m n
...                        | forward m≤n   =  forward (s≤s m≤n)
...                        | flipped n≤m   =  flipped (s≤s n≤m)
Agda-}

\func <=-total'' (m n : Nat) : Total m n
  | m, 0 => flipped z<=n
  | 0, suc n => forward z<=n
  | suc m, suc n => \case <=-total'' m n \with {
    | forward m<=n => forward (s<=s m<=n)
    | flipped n<=m => flipped (s<=s n<=m)
  }