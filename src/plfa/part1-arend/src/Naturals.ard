{-Agda
data ℕ : Set where
  zero : ℕ
  suc  : ℕ → ℕ
Agda-}

\data Nat'
  | zero'
  | suc' Nat'

{-Agda
-- Your code goes here
Agda-}

\func seven : Nat' => suc' (suc' (suc' (suc' (suc' (suc' (suc' zero'))))))

{-Agda
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl)
open Eq.≡-Reasoning using (begin_; _≡⟨⟩_; _∎)
Agda-}

\import Paths (==<, qed)

-- TODO type inference doesn't work without explicit signatures
-- TODO extract these to a separate package

\func \infixr 2 ==<> {A : \Type} (a : A) {a' : A} (p : a = a') : a = a' => a ==< p

\func \fix 3 qed' {A : \Type} (a : A) : a = a => qed a

{-Agda
_+_ : ℕ → ℕ → ℕ
zero + n = n
(suc m) + n = suc (m + n)
Agda-}

\func \infixl 6 +' (n m : Nat') : Nat' \elim n
  | zero' => m
  | suc' n => suc' (n +' m)

-- We will use builtin Nat and + below

\open Nat (+)

{-Agda
_ : 2 + 3 ≡ 5
_ =
  begin
    2 + 3
  ≡⟨⟩    -- is shorthand for
    (suc (suc zero)) + (suc (suc (suc zero)))
  ≡⟨⟩    -- inductive case
    suc ((suc zero) + (suc (suc (suc zero))))
  ≡⟨⟩    -- inductive case
    suc (suc (zero + (suc (suc (suc zero)))))
  ≡⟨⟩    -- base case
    suc (suc (suc (suc (suc zero))))
  ≡⟨⟩    -- is longhand for
    5
  ∎
Agda-}

\func twoPlusTheeIsFive : 2 + 3 = 5 =>
  2 + 3 ==<>
  (suc (suc zero)) + (suc (suc (suc zero))) ==<>
  suc ((suc zero) + (suc (suc (suc zero)))) ==<>
  suc (suc (zero + (suc (suc (suc zero))))) ==<>
  suc (suc (suc (suc (suc zero)))) ==<>
  5 `qed

{-Agda
_ : 2 + 3 ≡ 5
_ =
  begin
    2 + 3
  ≡⟨⟩
    suc (1 + 3)
  ≡⟨⟩
    suc (suc (0 + 3))
  ≡⟨⟩
    suc (suc 3)
  ≡⟨⟩
    5
  ∎
Agda-}

\func twoPlusTheeIsFive' : 2 + 3 = 5 =>
  2 + 3 ==<>
  suc (1 + 3) ==<>
  suc (suc (0 + 3)) ==<>
  suc (suc 3) ==<>
  5 `qed