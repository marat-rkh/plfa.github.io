{-Agda-
module plfa.part1.Connectives where
-Agda-}

-- Arend uses a "propositions as some types" aproach to encode logic. There is as a special universe `\Prop`
-- of types that has at most one element. Empty types correspond to false propositions,
-- one element types correspond to true propositions.
-- See: https://arend-lang.github.io/documentation/language-reference/expressions/universes
-- See: https://ncatlab.org/nlab/show/propositions+as+types#PropositionsAsSomeTypes

{-Agda-
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl)
open Eq.≡-Reasoning
open import Data.Nat using (ℕ)
open import Function using (_∘_)
open import plfa.part1.Isomorphism using (_≃_; _≲_; extensionality)
open plfa.part1.Isomorphism.≃-Reasoning
-Agda-}

\import Paths (==<, >==, qed)
\import Function (o)
\import util.Equiv (=~, =~-Reasoning)
\open =~-Reasoning
\import Equiv (>->)
\import util.Function (extensionality)

{-Agda-
data _×_ (A B : Set) : Set where

  ⟨_,_⟩ :
      A
    → B
      -----
    → A × B
-Agda-}

\data \infixr 2 x (A B : \Type)
  | prod A B

-- Conjunction is a product over `\Prop`

\func \infixr 2 && (A B : \Prop) : \Prop => A x B

{-Agda-
proj₁ : ∀ {A B : Set}
  → A × B
    -----
  → A
proj₁ ⟨ x , y ⟩ = x

proj₂ : ∀ {A B : Set}
  → A × B
    -----
  → B
proj₂ ⟨ x , y ⟩ = y
-Agda-}

\func proj1 {A B : \Type} (w : A x B) : A
  | prod a b => a

\func proj2 {A B : \Type} (w : A x B) : B
  | prod a b => b

{-Agda-
η-× : ∀ {A B : Set} (w : A × B) → ⟨ proj₁ w , proj₂ w ⟩ ≡ w
η-× ⟨ x , y ⟩ = refl
-Agda-}

\func eta-x {A B : \Type} (w : A x B) : prod (proj1 w) (proj2 w) = w
  | prod a b => idp

{-Agda-
record _×′_ (A B : Set) : Set where
  constructor ⟨_,_⟩′
  field
    proj₁′ : A
    proj₂′ : B
open _×′_
-Agda-}

\record \infixr 2 x' (A B : \Type)
  | proj1' : A
  | proj2' : B

\func \infixr 2 prod' {A B : \Type} (a : A) (b : B) : A x' B \cowith
  | proj1' => a
  | proj2' => b

{-Agda-
η-×′ : ∀ {A B : Set} (w : A ×′ B) → ⟨ proj₁′ w , proj₂′ w ⟩′ ≡ w
η-×′ w = refl
-Agda-}

\func eta-&&' {A B : \Type} (w : A x' B) : w.proj1' prod' w.proj2' = w => idp

{-Agda-
data Bool : Set where
  true  : Bool
  false : Bool

data Tri : Set where
  aa : Tri
  bb : Tri
  cc : Tri
-Agda-}

\data Bool | true | false

\data Tri | aa | bb | cc

{-Agda-
×-count : Bool × Tri → ℕ
×-count ⟨ true  , aa ⟩  =  1
×-count ⟨ true  , bb ⟩  =  2
×-count ⟨ true  , cc ⟩  =  3
×-count ⟨ false , aa ⟩  =  4
×-count ⟨ false , bb ⟩  =  5
×-count ⟨ false , cc ⟩  =  6
-Agda-}

\func x-count (bt : Bool x Tri) : Nat
  | prod true aa => 1
  | prod true bb => 2
  | prod true cc => 3
  | prod false aa => 4
  | prod false bb => 5
  | prod false cc => 6

{-Agda-
×-comm : ∀ {A B : Set} → A × B ≃ B × A
×-comm =
  record
    { to       =  λ{ ⟨ x , y ⟩ → ⟨ y , x ⟩ }
    ; from     =  λ{ ⟨ y , x ⟩ → ⟨ x , y ⟩ }
    ; from∘to  =  λ{ ⟨ x , y ⟩ → refl }
    ; to∘from  =  λ{ ⟨ y , x ⟩ → refl }
    }
-Agda-}

\func x-comm {A B : \Type} : A x B =~ B x A \cowith
  | f (p : A x B) : B x A \with {
    | prod x y => prod y x
  }
  | ret (p : B x A) : A x B \with {
    | prod y x => prod x y
  }
  | ret_f (p : A x B) : ret (f p) = p \with {
    | prod x y => idp
  }
  | f_sec (p : B x A) : f (ret p) = p \with {
    | prod y x => idp
  }

-- (!) In Arend, we can prove that product is purely commutative (without isomorphism).
-- The proof uses builtin function `iso`, which basically states that isomorphism implies equality
-- (or, better read, equivalence implies identity). This is called the univalence principle.

\func x-comm' {A B : \Type} : A x B = B x A =>
  path (iso x-comm.f x-comm.ret x-comm.ret_f x-comm.f_sec)

-- The same using a library function `equiv=`

\import Equiv.Sigma (equiv=)

\func x-comm'' {A B : \Type} : A x B = B x A => equiv= x-comm

{-Agda-
×-assoc : ∀ {A B C : Set} → (A × B) × C ≃ A × (B × C)
×-assoc =
  record
    { to      = λ{ ⟨ ⟨ x , y ⟩ , z ⟩ → ⟨ x , ⟨ y , z ⟩ ⟩ }
    ; from    = λ{ ⟨ x , ⟨ y , z ⟩ ⟩ → ⟨ ⟨ x , y ⟩ , z ⟩ }
    ; from∘to = λ{ ⟨ ⟨ x , y ⟩ , z ⟩ → refl }
    ; to∘from = λ{ ⟨ x , ⟨ y , z ⟩ ⟩ → refl }
    }
-Agda-}

\func x-assoc {A B C : \Type} : (A x B) x C =~ A x (B x C) \cowith
  | f (p : (A x B) x C) : A x (B x C) \with {
    | prod (prod a b) c => prod a (prod b c)
  }
  | ret (p : A x (B x C)) : (A x B) x C \with {
    | prod a (prod b c) => prod (prod a b) c
  }
  | ret_f (p : (A x B) x C) : ret (f p) = p \with {
    | prod (prod a b) c => idp
  }
  | f_sec (p : A x (B x C)) : f (ret p) = p \with {
    | prod a (prod b c) => idp
  }

\func x-assoc' {A B C : \Type} : (A x B) x C = A x (B x C) => equiv= x-assoc

{-Agda-
-- Your code goes here
-Agda-}

\import part1.Isomorphism (<=>)

\func <=>=~x {A B : \Type} : (A <=> B) =~ (A -> B) x (B -> A) \cowith
  | f (A<=>B : A <=> B) : (A -> B) x (B -> A) => prod A<=>B.to A<=>B.from
  | ret (AxB : (A -> B) x (B -> A)) : A <=> B \cowith {
    | to => proj1 AxB
    | from => proj2 AxB
  }
  | ret_f (A<=>B : A <=> B) => idp
  | f_sec (AxB : (A -> B) x (B -> A)) : f (ret AxB) = AxB \with {
    | prod AB BA => idp
  }

{-Agda-
data ⊤ : Set where

  tt :
    --
    ⊤
-Agda-}

\data T | tt

{-Agda-
η-⊤ : ∀ (w : ⊤) → tt ≡ w
η-⊤ tt = refl
-Agda-}

\func eta-T (w : T) : tt = w
  | tt => idp

{-Agda-
record ⊤′ : Set where
  constructor tt′
-Agda-}

\record T'

\func tt' : T' \cowith

{-Agda-
η-⊤′ : ∀ (w : ⊤′) → tt′ ≡ w
η-⊤′ w = refl
-Agda-}

\func eta-T' (w : T') : tt' = w => idp

{-Agda-
truth′ : ⊤′
truth′ = _
-Agda-}

-- Arend doesn't have this.

{-Agda-
⊤-count : ⊤ → ℕ
⊤-count tt = 1
-Agda-}

\func T-count (w : T) : Nat
  | tt => 1

{-Agda-
⊤-identityˡ : ∀ {A : Set} → ⊤ × A ≃ A
⊤-identityˡ =
  record
    { to      = λ{ ⟨ tt , x ⟩ → x }
    ; from    = λ{ x → ⟨ tt , x ⟩ }
    ; from∘to = λ{ ⟨ tt , x ⟩ → refl }
    ; to∘from = λ{ x → refl }
    }
-Agda-}

\func T-identity-left {A : \Type} : T x A =~ A \cowith
  | f => \lam p => proj2 p
  | ret => \lam a => prod tt a
  | ret_f (p : T x A) : prod tt (proj2 p) = p \with {
    | prod tt a => idp
  }
  | f_sec => \lam a => idp

{-Agda-
⊤-identityʳ : ∀ {A : Set} → (A × ⊤) ≃ A
⊤-identityʳ {A} =
  ≃-begin
    (A × ⊤)
  ≃⟨ ×-comm ⟩
    (⊤ × A)
  ≃⟨ ⊤-identityˡ ⟩
    A
  ≃-∎
-Agda-}

\func T-identity-right {A : \Type} : A x T =~ A =>
  (A x T) =~< x-comm >=~
  (T x A) =~< T-identity-left >=~
  A `=~-qed

{-Agda-
data _⊎_ (A B : Set) : Set where

  inj₁ :
      A
      -----
    → A ⊎ B

  inj₂ :
      B
      -----
    → A ⊎ B
-Agda-}

\data \infixr 1 u (A B : \Type)
  | inj1 A
  | inj2 B

-- (!) Note that `u` is not in `\Prop`: even if `A` and `B` are in `\Prop`, `A u B` can have
-- more than one element. So, we cannot use `u` to encode disjunction in Arend. To fix this,
-- we can enforce a data definition to be in `\Prop` by using `\truncated` keyword
-- and explicit `: \Prop` annotation:

\truncated \data \infixr 1 || (A B : \Prop) : \Prop
  | byLeft A
  | byRight B

-- Truncating a data has one crucial consequence: any function defined by recursion over a truncated data
-- must have the codomain lying in the universe of the data. In our case, functions over `A || B`
-- can only return types in `\Prop`.
-- See: https://arend-lang.github.io/documentation/language-reference/definitions/data#truncation

{-Agda-
case-⊎ : ∀ {A B C : Set}
  → (A → C)
  → (B → C)
  → A ⊎ B
    -----------
  → C
case-⊎ f g (inj₁ x) = f x
case-⊎ f g (inj₂ y) = g y
-Agda-}

\func case-u {A B C : \Type} (f : A -> C) (g : B -> C) (w : A u B) : C \elim w
  | inj1 x => f x
  | inj2 y => g y

{-Agda-
η-⊎ : ∀ {A B : Set} (w : A ⊎ B) → case-⊎ inj₁ inj₂ w ≡ w
η-⊎ (inj₁ x) = refl
η-⊎ (inj₂ y) = refl
-Agda-}

\func eta-u {A B : \Type} (w : A u B) : case-u inj1 inj2 w = w
  | inj1 x => idp
  | inj2 y => idp

{-Agda-
uniq-⊎ : ∀ {A B C : Set} (h : A ⊎ B → C) (w : A ⊎ B) →
  case-⊎ (h ∘ inj₁) (h ∘ inj₂) w ≡ h w
uniq-⊎ h (inj₁ x) = refl
uniq-⊎ h (inj₂ y) = refl
-Agda-}

\func uniq-u {A B C : \Type} (h : A u B -> C) (w : A u B) : case-u (h o inj1) (h o inj2) w = h w \elim w
  | inj1 x => idp
  | inj2 y => idp

{-Agda-
⊎-count : Bool ⊎ Tri → ℕ
⊎-count (inj₁ true)   =  1
⊎-count (inj₁ false)  =  2
⊎-count (inj₂ aa)     =  3
⊎-count (inj₂ bb)     =  4
⊎-count (inj₂ cc)     =  5
-Agda-}

\func u-count (w : Bool u Tri) : Nat
  | inj1 true => 1
  | inj1 false => 2
  | inj2 aa => 3
  | inj2 bb => 4
  | inj2 cc => 5

{-Agda-
-- Your code goes here
-Agda-}

\func u-comm {A B : \Type} : (A u B) =~ (B u A) \cowith
  | f => \lam w => case-u inj2 inj1 w
  | ret => \lam w => case-u inj2 inj1 w
  | ret_f (w : A u B) : case-u inj2 inj1 (case-u inj2 inj1 w) = w \with {
    | inj1 a => idp
    | inj2 b => idp
  }
  | f_sec (w : B u A) : case-u inj2 inj1 (case-u inj2 inj1 w) = w \with {
    | inj1 a => idp
    | inj2 b => idp
  }

{-Agda-
-- Your code goes here
-Agda-}

\func u-assoc {A B C : \Type} : ((A u B) u C) =~ (A u (B u C)) \cowith
  | f (w : (A u B) u C) : A u B u C \with {
    | inj1 (inj1 a) => inj1 a
    | inj1 (inj2 b) => inj2 (inj1 b)
    | inj2 c => inj2 (inj2 c)
  }
  | ret (w : A u B u C) : (A u B) u C \with {
    | inj1 a => inj1 (inj1 a)
    | inj2 (inj1 b) => inj1 (inj2 b)
    | inj2 (inj2 c) => inj2 c
  }
  | ret_f (w : (A u B) u C) : ret (f w) = w \with {
    | inj1 (inj1 a) => idp
    | inj1 (inj2 b) => idp
    | inj2 c => idp
  }
  | f_sec (w : A u B u C) : f (ret w) = w \with {
    | inj1 a => idp
    | inj2 (inj1 b) => idp
    | inj2 (inj2 c) => idp
  }

{-Agda-
data ⊥ : Set where
  -- no clauses!
-Agda-}

\data _|_

{-Agda-
⊥-elim : ∀ {A : Set}
  → ⊥
    --
  → A
⊥-elim ()
-Agda-}

\func _|_-elim {A : \Type} (e : _|_) : A

{-Agda-
uniq-⊥ : ∀ {C : Set} (h : ⊥ → C) (w : ⊥) → ⊥-elim w ≡ h w
uniq-⊥ h ()
-Agda-}

\func uniq-_|_ {C : \Type} (h : _|_ -> C) (w : _|_) : _|_-elim w = h w

{-Agda-
⊥-count : ⊥ → ℕ
⊥-count ()
-Agda-}

\func _|_-count (e : _|_) : Nat

{-Agda-
-- Your code goes here
-Agda-}

\func _|_-identity-left {A : \Type} : (_|_ u A) =~ A \cowith
  | f (w : _|_ u A) : A \with {
    | inj1 e => _|_-elim e
    | inj2 a => a
  }
  | ret => inj2
  | ret_f (w : _|_ u A) : inj2 (f w) = w \with {
    | inj1 e => _|_-elim e
    | inj2 a => idp
  }
  | f_sec => \lam a => idp

{-Agda-
-- Your code goes here
-Agda-}

\func _|_-identity-right {A : \Type} : (A u _|_) =~ A =>
  (A u _|_) =~< u-comm >=~
  (_|_ u A) =~< _|_-identity-left >=~
  A `=~-qed