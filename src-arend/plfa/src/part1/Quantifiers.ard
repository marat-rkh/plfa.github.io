{-Agda-
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl)
open import Data.Nat using (ℕ; zero; suc; _+_; _*_)
open import Relation.Nullary using (¬_)
open import Data.Product using (_×_; proj₁; proj₂) renaming (_,_ to ⟨_,_⟩)
open import Data.Sum using (_⊎_; inj₁; inj₂)
open import plfa.part1.Isomorphism using (_≃_; extensionality)
-Agda-}

\open Nat (+, *)
\import Logic (Not, absurd, ||)
\open || (byLeft, byRight)
\import util.Logic (&&)
\open && (prod, proj1, proj2)
\import util.Equiv (=~)
\import part1.Isomorphism (extensionality)

{-Agda-
∀-elim : ∀ {A : Set} {B : A → Set}
  → (L : ∀ (x : A) → B x)
  → (M : A)
    -----------------
  → B M
∀-elim L M = L M
-Agda-}

\func Pi-elim {A : \Type} {B : A -> \Type} (L : \Pi (a : A) -> B a) (M : A) : B M => L M

{-Agda-
postulate
  ∀-distrib-× : ∀ {A : Set} {B C : A → Set} →
    (∀ (x : A) → B x × C x) ≃ (∀ (x : A) → B x) × (∀ (x : A) → C x)
-Agda-}

\import Logic (propExt)

\func Pi-distrib-&& {A : \Type} {B C : A -> \Prop} :
  (\Pi (a : A) -> B a && C a) = (\Pi (a : A) -> B a) && (\Pi (a : A) -> C a) =>
  propExt ([=>] {A} {B} {C}) ([<=] {A} {B} {C})
  \where {
    \func [=>] {A : \Type} {B C : A -> \Prop} (p : \Pi (a : A) -> B a && C a) :
      (\Pi (a : A) -> B a) && (\Pi (a : A) -> C a) =>
      prod (\lam a => proj1 (p a)) (\lam a => (proj2 (p a)))

    \func [<=] {A : \Type} {B C : A -> \Prop} (p : (\Pi (a : A) -> B a) && (\Pi (a : A) -> C a)) :
      \Pi (a : A) -> B a && C a =>
      \lam a => prod ((proj1 p) a) ((proj2 p) a)
  }

{-Agda-
postulate
  ⊎∀-implies-∀⊎ : ∀ {A : Set} {B C : A → Set} →
    (∀ (x : A) → B x) ⊎ (∀ (x : A) → C x)  →  ∀ (x : A) → B x ⊎ C x
-Agda-}

\func ||-Pi-implies-Pi-|| {A : \Type} {B C : A -> \Prop} (p : (\Pi (a : A) -> B a) || (\Pi (a : A) -> C a)) :
  \Pi (a : A) -> B a || C a \elim p
  | byLeft a=>Ba => \lam a => byLeft (a=>Ba a)
  | byRight a=>Ca => \lam a => byRight (a=>Ca a)

\func Pi-||->||-Pi =>
  \Pi {A : \Type} {B C : A -> \Prop} -> (\Pi (a : A) -> B a || C a) -> (\Pi (a : A) -> B a) || (\Pi (a : A) -> C a)

\import Data.Bool

\func Pi-||-doesn't-imply-||-Pi : Not (Pi-||->||-Pi) =>
  \lam p => \case p {Bool} {__ = true} {__ = false} bool-is-true-or-false \with {
    | byLeft any-bool-is-true => \case any-bool-is-true false \with {}
    | byRight any-bool-is-false => \case any-bool-is-false true \with {}
  }

  \where {
    \func bool-is-true-or-false (b : Bool) : (b = true) || (b = false) \elim b
      | true => byLeft idp
      | false => byRight idp
  }

{-Agda-
data Tri : Set where
  aa : Tri
  bb : Tri
  cc : Tri
-Agda-}

\import part1.Connectives (Tri, x)
\open Tri
\import part1.Connectives (x, proj1 \as x-proj1, proj2 \as x-proj2)
\import part1.Isomorphism (Pi-extensionality)
\import Paths.Meta (rewrite)

\func Pi-x {B : Tri -> \Type} : (\Pi (t : Tri) -> B t) =~ B aa x B bb x B cc \cowith
  | f => \lam p => x.prod (p aa) (x.prod (p bb) (p cc))
  | ret => \lam p t => \case t \as t' \return B t' \with {
    | aa => x-proj1 p
    | bb => x-proj1 (x-proj2 p)
    | cc => x-proj2 (x-proj2 p)
  }
  | ret_f => \lam p => Pi-extensionality {Tri} {B} (\lam x => \case x \as x', idp : x = x' \with {
    | aa, eq => rewrite eq idp
    | bb, eq => rewrite eq idp
    | cc, eq => rewrite eq idp
  })
  | f_sec => \lam p => \case p \as p', idp : p = p' \with {
    | x.prod a (x.prod b c), eq => rewrite eq idp
  }

{-Agda-
data Σ (A : Set) (B : A → Set) : Set where
  ⟨_,_⟩ : (x : A) → B x → Σ A B
-Agda-}

\data Sigma (A : \Type) (B : A -> \Prop)
  | pair (x : A) (B x)

-- (!) Note that `Sigma` is not generally in `\Prop`. We can fix this using truncation as we did for disjunction
-- in `part1.Connectives`. This time, we will use `TruncP` from the standard library, it allows truncating any type
-- to `\Prop`. `TruncP` has 2 contructors:
-- 1. `inP` - constructs values of `TruncP` from any type.
-- 2. `truncP` - states that any 2 values of `TruncP` are identical.
-- Note that `truncP` is special. It doesn't construct values of `TruncP`, but rather constructs values
-- of identity type on `TruncP`. This is a feature of higher inductive types. `TruncP` is an example of such type.
-- See: https://arend-lang.github.io/documentation/language-reference/definitions/hits

\import Logic (TruncP, inP)

\func Exists-example (A : \Type) (B : A -> \Prop) (a : A) (b : B a) : TruncP (Sigma A B) => inP (pair a b)

{-Agda-
Σ-syntax = Σ
infix 2 Σ-syntax
syntax Σ-syntax A (λ x → B) = Σ[ x ∈ A ] B
-Agda-}

-- Arend has a special builtin type `\Sigma` for dependent tuples:

\func Sigma-syntax-example (A : \Type) (B : A -> \Prop) (a : A) (b : B a) : \Sigma (a : A) (B a) => (a, b)

-- For `TruncP (\Sigma ...)` convenient syntax is provided by the meta definition `∃`.
-- See: https://arend-lang.github.io/about/arend-features#language-extensions

\import Logic.Meta (∃)

\func Exists-syntax-example (A : \Type) (B : A -> \Prop) (a : A) (b : B a) : ∃ (a : A) (B a) => inP (a, b)

{-Agda-
record Σ′ (A : Set) (B : A → Set) : Set where
  field
    proj₁′ : A
    proj₂′ : B proj₁′
-Agda-}

\record Sigma' (A : \Type) (B : A -> \Prop)
  | proj1' : A
  | proj2' : B proj1'

{-Agda-
∃ : ∀ {A : Set} (B : A → Set) → Set
∃ {A} B = Σ A B

∃-syntax = ∃
syntax ∃-syntax (λ x → B) = ∃[ x ] B
-Agda-}

\func Exists-syntax-example' (A : \Type) (B : A -> \Type) (a : A) (b : B a) : ∃ {a} (B a) => inP (a, b)

{-Agda-
∃-elim : ∀ {A : Set} {B : A → Set} {C : Set}
  → (∀ x → B x → C)
  → ∃[ x ] B x
    ---------------
  → C
∃-elim f ⟨ x , y ⟩ = f x y
-Agda-}

\func Exists-elim {A : \Type} {B : A -> \Prop} {C : \Prop}
                  (f : \Pi (x : A) -> B x -> C)
                  (e : ∃ {x} (B x)) : C \elim e
  | inP (x, y) => f x y

{-Agda-
∀∃-currying : ∀ {A : Set} {B : A → Set} {C : Set}
  → (∀ x → B x → C) ≃ (∃[ x ] B x → C)
∀∃-currying =
  record
    { to      =  λ{ f → λ{ ⟨ x , y ⟩ → f x y }}
    ; from    =  λ{ g → λ{ x → λ{ y → g ⟨ x , y ⟩ }}}
    ; from∘to =  λ{ f → refl }
    ; to∘from =  λ{ g → extensionality λ{ ⟨ x , y ⟩ → refl }}
    }
-Agda-}

\func Pi-Sigma-currying {A : \Type} {B : A -> \Type} {C : \Type} :
  (\Pi (x : A) -> B x -> C) =~ (\Sigma (x : A) (B x) -> C) \cowith
  | f => \lam f' xy => \case xy \with {
    | (x, y) => f' x y
  }
  | ret => \lam g x y => g (x, y)
  | ret_f => \lam f => idp
  | f_sec => \lam g => extensionality (\lam xy => \case xy \as xy', idp : xy = xy' \with {
    | (x, y), ab=ab' => rewrite ab=ab' idp
  })

{-Agda-
postulate
  ∃-distrib-⊎ : ∀ {A : Set} {B C : A → Set} →
    ∃[ x ] (B x ⊎ C x) ≃ (∃[ x ] B x) ⊎ (∃[ x ] C x)
-Agda-}

\func Exists-distrib-|| {A : \Type} {B C : A -> \Prop} : ∃ (a : A) (B a || C a) = (∃ (a : A) (B a) || ∃ (a : A) (C a)) =>
  propExt ([=>] {A} {B} {C}) ([<=] {A} {B} {C})
  \where {
    \func [=>] {A : \Type} {B C : A -> \Prop} (p : ∃ (a : A) (B a || C a)) : ∃ (a : A) (B a) || ∃ (a : A) (C a) => {?}

    \func [<=] {A : \Type} {B C : A -> \Prop} (p : ∃ (a : A) (B a) || ∃ (a : A) (C a)) : ∃ (a : A) (B a || C a) => {?}
  }