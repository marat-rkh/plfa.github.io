{-Agda-
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl)
open import Data.Nat using (ℕ; zero; suc; _+_; _*_)
open import Relation.Nullary using (¬_)
open import Data.Product using (_×_; proj₁; proj₂) renaming (_,_ to ⟨_,_⟩)
open import Data.Sum using (_⊎_; inj₁; inj₂)
open import plfa.part1.Isomorphism using (_≃_; extensionality)
-Agda-}

\open Nat (+, *)
\import Logic (Empty, Not, absurd, ||)
\open || (byLeft, byRight)
\import util.Logic (&&)
\open && (prod, proj1, proj2)
\import util.Equiv (=~)
\import part1.Isomorphism (extensionality)

{-Agda-
∀-elim : ∀ {A : Set} {B : A → Set}
  → (L : ∀ (x : A) → B x)
  → (M : A)
    -----------------
  → B M
∀-elim L M = L M
-Agda-}

\func Pi-elim {A : \Type} {B : A -> \Type} (L : \Pi (a : A) -> B a) (M : A) : B M => L M

{-Agda-
postulate
  ∀-distrib-× : ∀ {A : Set} {B C : A → Set} →
    (∀ (x : A) → B x × C x) ≃ (∀ (x : A) → B x) × (∀ (x : A) → C x)
-Agda-}

\import Logic (propExt)

\func Pi-distrib-&& {A : \Type} {B C : A -> \Prop} :
  (\Pi (a : A) -> B a && C a) = (\Pi (a : A) -> B a) && (\Pi (a : A) -> C a) =>
  propExt ([=>] {A} {B} {C}) ([<=] {A} {B} {C})
  \where {
    \func [=>] {A : \Type} {B C : A -> \Prop} (p : \Pi (a : A) -> B a && C a) :
      (\Pi (a : A) -> B a) && (\Pi (a : A) -> C a) =>
      prod (\lam a => proj1 (p a)) (\lam a => (proj2 (p a)))

    \func [<=] {A : \Type} {B C : A -> \Prop} (p : (\Pi (a : A) -> B a) && (\Pi (a : A) -> C a)) :
      \Pi (a : A) -> B a && C a =>
      \lam a => prod ((proj1 p) a) ((proj2 p) a)
  }

{-Agda-
postulate
  ⊎∀-implies-∀⊎ : ∀ {A : Set} {B C : A → Set} →
    (∀ (x : A) → B x) ⊎ (∀ (x : A) → C x)  →  ∀ (x : A) → B x ⊎ C x
-Agda-}

\func ||-Pi->Pi-|| {A : \Type} {B C : A -> \Prop} (p : (\Pi (a : A) -> B a) || (\Pi (a : A) -> C a)) :
  \Pi (a : A) -> B a || C a \elim p
  | byLeft a=>Ba => \lam a => byLeft (a=>Ba a)
  | byRight a=>Ca => \lam a => byRight (a=>Ca a)

\func Pi-||->||-Pi =>
  \Pi {A : \Type} {B C : A -> \Prop} -> (\Pi (a : A) -> B a || C a) -> (\Pi (a : A) -> B a) || (\Pi (a : A) -> C a)

\import Data.Bool

\func Pi-||->||-Pi-is-false : Not (Pi-||->||-Pi) =>
  \lam p => \case p {Bool} {__ = true} {__ = false} bool-is-true-or-false \with {
    | byLeft any-bool-is-true => \case any-bool-is-true false \with {}
    | byRight any-bool-is-false => \case any-bool-is-false true \with {}
  }

  \where {
    \func bool-is-true-or-false (b : Bool) : (b = true) || (b = false) \elim b
      | true => byLeft idp
      | false => byRight idp
  }

{-Agda-
data Tri : Set where
  aa : Tri
  bb : Tri
  cc : Tri
-Agda-}

\import part1.Connectives (Tri, x)
\open Tri
\import part1.Connectives (x, proj1 \as x-proj1, proj2 \as x-proj2)
\import part1.Isomorphism (Pi-extensionality)
\import Paths.Meta (rewrite)

\func Pi-x {B : Tri -> \Type} : (\Pi (t : Tri) -> B t) =~ B aa x B bb x B cc \cowith
  | f => \lam p => x.prod (p aa) (x.prod (p bb) (p cc))
  | ret => \lam p t => \case t \as t' \return B t' \with {
    | aa => x-proj1 p
    | bb => x-proj1 (x-proj2 p)
    | cc => x-proj2 (x-proj2 p)
  }
  | ret_f => \lam p => Pi-extensionality {Tri} {B} (\lam x => \case x \as x', idp : x = x' \with {
    | aa, eq => rewrite eq idp
    | bb, eq => rewrite eq idp
    | cc, eq => rewrite eq idp
  })
  | f_sec => \lam p => \case p \as p', idp : p = p' \with {
    | x.prod a (x.prod b c), eq => rewrite eq idp
  }

{-Agda-
data Σ (A : Set) (B : A → Set) : Set where
  ⟨_,_⟩ : (x : A) → B x → Σ A B
-Agda-}

\data Sigma (A : \Type) (B : A -> \Prop)
  | pair (x : A) (B x)

-- (!) Note that `Sigma` is not generally in `\Prop`. We can fix this using truncation as we did for disjunction
-- in `part1.Connectives`. This time, we will use `TruncP` from the standard library, it allows truncating any type
-- to `\Prop`. `TruncP` has 2 contructors:
-- 1. `inP` - constructs values of `TruncP` from any type.
-- 2. `truncP` - states that any 2 values of `TruncP` are identical.
-- Note that `truncP` is special. It doesn't construct values of `TruncP`, but rather constructs values
-- of identity type on `TruncP`. This is a feature of higher inductive types. `TruncP` is an example of such type.
-- See: https://arend-lang.github.io/documentation/language-reference/definitions/hits

\import Logic (TruncP, inP)

\func Exists-example (A : \Type) (B : A -> \Prop) (a : A) (b : B a) : TruncP (Sigma A B) => inP (pair a b)

{-Agda-
Σ-syntax = Σ
infix 2 Σ-syntax
syntax Σ-syntax A (λ x → B) = Σ[ x ∈ A ] B
-Agda-}

-- Arend has a special builtin type `\Sigma` for dependent tuples:

\func Sigma-syntax-example (A : \Type) (B : A -> \Prop) (a : A) (b : B a) : \Sigma (a : A) (B a) => (a, b)

-- For `TruncP (\Sigma ...)` convenient syntax is provided by the meta definition `∃`.
-- See: https://arend-lang.github.io/about/arend-features#language-extensions

\import Logic.Meta (∃)

\func Exists-syntax-example (A : \Type) (B : A -> \Prop) (a : A) (b : B a) : ∃ (a : A) (B a) => inP (a, b)

{-Agda-
record Σ′ (A : Set) (B : A → Set) : Set where
  field
    proj₁′ : A
    proj₂′ : B proj₁′
-Agda-}

\record Sigma' (A : \Type) (B : A -> \Prop)
  | proj1' : A
  | proj2' : B proj1'

{-Agda-
∃ : ∀ {A : Set} (B : A → Set) → Set
∃ {A} B = Σ A B

∃-syntax = ∃
syntax ∃-syntax (λ x → B) = ∃[ x ] B
-Agda-}

\func Exists-syntax-example' (A : \Type) (B : A -> \Type) (a : A) (b : B a) : ∃ {a} (B a) => inP (a, b)

{-Agda-
∃-elim : ∀ {A : Set} {B : A → Set} {C : Set}
  → (∀ x → B x → C)
  → ∃[ x ] B x
    ---------------
  → C
∃-elim f ⟨ x , y ⟩ = f x y
-Agda-}

\func Exists-elim {A : \Type} {B : A -> \Prop} {C : \Prop}
                  (f : \Pi (x : A) -> B x -> C)
                  (e : ∃ {x} (B x)) : C \elim e
  | inP (x, y) => f x y

{-Agda-
∀∃-currying : ∀ {A : Set} {B : A → Set} {C : Set}
  → (∀ x → B x → C) ≃ (∃[ x ] B x → C)
∀∃-currying =
  record
    { to      =  λ{ f → λ{ ⟨ x , y ⟩ → f x y }}
    ; from    =  λ{ g → λ{ x → λ{ y → g ⟨ x , y ⟩ }}}
    ; from∘to =  λ{ f → refl }
    ; to∘from =  λ{ g → extensionality λ{ ⟨ x , y ⟩ → refl }}
    }
-Agda-}

\func Pi-Sigma-currying {A : \Type} {B : A -> \Type} {C : \Type} :
  (\Pi (x : A) -> B x -> C) =~ (\Sigma (x : A) (B x) -> C) \cowith
  | f => \lam f' xy => \case xy \with {
    | (x, y) => f' x y
  }
  | ret => \lam g x y => g (x, y)
  | ret_f => \lam f => idp
  | f_sec => \lam g => extensionality (\lam xy => \case xy \as xy', idp : xy = xy' \with {
    | (x, y), ab=ab' => rewrite ab=ab' idp
  })

{-Agda-
postulate
  ∃-distrib-⊎ : ∀ {A : Set} {B C : A → Set} →
    ∃[ x ] (B x ⊎ C x) ≃ (∃[ x ] B x) ⊎ (∃[ x ] C x)
-Agda-}

\func Exists-distrib-|| {A : \Type} {B C : A -> \Prop} : ∃ {a} (B a || C a) = (∃ {a} (B a) || ∃ {a} (C a)) =>
  propExt ([=>] {A} {B} {C}) ([<=] {A} {B} {C})
  \where {
    \func [=>] {A : \Type} {B C : A -> \Prop} (p : ∃ {a} (B a || C a)) : ∃ {a} (B a) || ∃ {a} (C a)
      | inP (a, b||c) => \case b||c \with {
        | byLeft b => byLeft (inP (a, b))
        | byRight c => byRight (inP (a, c))
      }

    \func [<=] {A : \Type} {B C : A -> \Prop} (p : ∃ {a} (B a) || ∃ {a} (C a)) : ∃ {a} (B a || C a)
      | byLeft (inP (a, b)) => inP (a, byLeft b)
      | byRight (inP (a, c)) => inP (a, byRight c)
  }

{-Agda-
postulate
  ∃×-implies-×∃ : ∀ {A : Set} {B C : A → Set} →
    ∃[ x ] (B x × C x) → (∃[ x ] B x) × (∃[ x ] C x)
-Agda-}

\func Exists-&&->&&-Exists {A : \Type} {B C : A -> \Prop} (p : ∃ {a} (B a && C a)) : (∃ {a} (B a)) && (∃ {a} (C a))
  | inP (a, x.prod b c) => x.prod (inP (a, b)) (inP (a, c))

\func &&-Exists->Exists-&& => \Pi {A : \Type} {B C : A -> \Prop} -> (∃ {a} (B a)) && (∃ {a} (C a)) -> ∃ {a} (B a && C a)

\import Paths (inv, *>)

\func &&-Exists->Exists-&&-is-false : Not (&&-Exists->Exists-&&) =>
  \lam p => \case p {Bool} {\lam b => b = true} {\lam b => b = false} (x.prod (inP (true, idp)) (inP (false, idp))) \with {
    | inP (b, x.prod b=true b=false) => \case (inv b=true) *> b=false \with {}
  }

-- TODO ∃-||

{-Agda-
data even : ℕ → Set
data odd  : ℕ → Set

data even where

  even-zero : even zero

  even-suc : ∀ {n : ℕ}
    → odd n
      ------------
    → even (suc n)

data odd where
  odd-suc : ∀ {n : ℕ}
    → even n
      -----------
    → odd (suc n)
-Agda-}

\import part1.Relations (even, odd, suc-even, suc-odd, zero-even)

{-Agda-
even-∃ : ∀ {n : ℕ} → even n → ∃[ m ] (    m * 2 ≡ n)
odd-∃  : ∀ {n : ℕ} →  odd n → ∃[ m ] (1 + m * 2 ≡ n)

even-∃ even-zero                       =  ⟨ zero , refl ⟩
even-∃ (even-suc o) with odd-∃ o
...                    | ⟨ m , refl ⟩  =  ⟨ suc m , refl ⟩

odd-∃  (odd-suc e)  with even-∃ e
...                    | ⟨ m , refl ⟩  =  ⟨ m , refl ⟩
-Agda-}

\import Paths (pmap)

\func even-Exists {n : Nat} (en : even n) : ∃ {m} (m * 2 = n)
  | {0}, zero-even => inP (0, idp)
  | {suc n}, suc-even o => \case odd-Exists o \with {
    | inP (m, p) => inP (suc m, pmap suc p)
  }

\func odd-Exists {n : Nat} (on : odd n) : ∃ {m} (1 + m * 2 = n)
  | {suc n}, suc-odd e => \case even-Exists e \with {
    | inP (m, p) => inP (m, pmap suc p)
  }

{-Agda-
∃-even : ∀ {n : ℕ} → ∃[ m ] (    m * 2 ≡ n) → even n
∃-odd  : ∀ {n : ℕ} → ∃[ m ] (1 + m * 2 ≡ n) →  odd n

∃-even ⟨  zero , refl ⟩  =  even-zero
∃-even ⟨ suc m , refl ⟩  =  even-suc (∃-odd ⟨ m , refl ⟩)

∃-odd  ⟨     m , refl ⟩  =  odd-suc (∃-even ⟨ m , refl ⟩)
-Agda-}

\import Arith.Nat (pred)

\func Exists-even {n : Nat} (e : ∃ {m} (m * 2 = n)) : even n \elim n
  | 0 => zero-even
  | suc n => suc-even (Exists-odd (lemma1 e))
  \where {
    \func lemma1 {n : Nat} (e : ∃ {m} (m * 2 = suc n)) : ∃ {k} (suc (k * 2) = n)
      | {0}, inP (0, ())
      | {0}, inP (suc n, ())
      | {suc n}, inP ((0, ()))
      | {suc n}, inP (suc m, p) => inP (m, pmap pred p)
  }

\func Exists-odd {n : Nat} (e : ∃ {m} (suc (m * 2) = n)) : odd n \elim n
  | 0 =>
    \let empty => TruncP.map e (\case __.2 \with {})
    \in absurd (TruncP.remove Path.inProp empty)
  | suc n =>
    \let e' : ∃ {m} (m * 2 = n) => TruncP.map e (\lam p => (p.1, pmap pred p.2))
    \in suc-odd (Exists-even e')

{-Agda-
-- Your code goes here
-Agda-}

-- TODO ∃-even-odd