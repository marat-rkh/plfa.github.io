{-Agda-
open import Data.Bool using (T; not)
open import Data.Empty using (⊥; ⊥-elim)
open import Data.List using (List; _∷_; [])
open import Data.Nat using (ℕ; zero; suc)
open import Data.Product using (∃-syntax; _×_)
open import Data.String using (String; _≟_)
open import Relation.Nullary using (Dec; yes; no; ¬_)
open import Relation.Nullary.Decidable using (⌊_⌋; False; toWitnessFalse)
open import Relation.Nullary.Negation using (¬?)
open import Relation.Binary.PropositionalEquality using (_≡_; _≢_; refl)
-Agda-}

\import Arith.Nat
\import Function.Meta ($)
\import Set

{-Agda-
Id : Set
Id = String

infix  5  ƛ_⇒_
infix  5  μ_⇒_
infixl 7  _·_
infix  8  `suc_
infix  9  `_

data Term : Set where
  `_                      :  Id → Term
  ƛ_⇒_                    :  Id → Term → Term
  _·_                     :  Term → Term → Term
  `zero                   :  Term
  `suc_                   :  Term → Term
  case_[zero⇒_|suc_⇒_]    :  Term → Term → Id → Term → Term
  μ_⇒_                    :  Id → Term → Term
-Agda-}

-- There is no String data type in Arend, so we will use natural numbers as identifiers.

\func Id => Nat

-- Here we import all identifiers that will be used in this chapter.

\import util.LambdaIdentifiers

\data Term
  | ref Id
  | lam Id Term
  | app \alias \infixl 7 ∙ Term Term
  | zero'
  | suc' Term
  | case (num : Term) (tzeroCase : Term) (tsucId : Id) (tsucCase : Term)
  | fixpoint Id Term

{-Agda-
two : Term
two = `suc `suc `zero

plus : Term
plus = μ "+" ⇒ ƛ "m" ⇒ ƛ "n" ⇒
         case ` "m"
           [zero⇒ ` "n"
           |suc "m" ⇒ `suc (` "+" · ` "m" · ` "n") ]
-Agda-}

\func two => suc' (suc' zero')

\func plus => fixpoint PLUS (lam M (lam N
    (case (ref M)
        (ref N)
        M (suc' (ref PLUS ∙ ref M ∙ ref N))
    )
))

{-Agda-
twoᶜ : Term
twoᶜ =  ƛ "s" ⇒ ƛ "z" ⇒ ` "s" · (` "s" · ` "z")

plusᶜ : Term
plusᶜ =  ƛ "m" ⇒ ƛ "n" ⇒ ƛ "s" ⇒ ƛ "z" ⇒
         ` "m" · ` "s" · (` "n" · ` "s" · ` "z")

sucᶜ : Term
sucᶜ = ƛ "n" ⇒ `suc (` "n")
-Agda-}

\func two-c => lam S (lam Z (ref S ∙ (ref S ∙ ref Z)))

\func plus-c => lam M (lam N (lam S (lam Z (ref M ∙ ref S ∙ (ref N ∙ ref S ∙ ref Z)))))

\func suc-c => lam N (suc' (ref N))

{-Agda-
-- Your code goes here
-Agda-}

\func mul => fixpoint MUL (lam M (lam N
    (case (ref M)
        zero'
        M (plus ∙ ref N ∙ (ref MUL ∙ ref M ∙ ref N))
    )
))

{-Agda-
-- Your code goes here
-Agda-}

\func zero-c => lam S (lam Z (ref Z))

\func mul-c1 => lam M (lam N (ref M ∙ (plus-c ∙ ref N) ∙ zero-c))

\func mul-c2 => lam M (lam N (lam S (lam Z (ref M ∙ (ref N ∙ ref S) ∙ ref Z))))

{-Agda-
ƛ′_⇒_ : Term → Term → Term
ƛ′ (` x) ⇒ N  =  ƛ x ⇒ N
ƛ′ _ ⇒ _      =  ⊥-elim impossible
  where postulate impossible : ⊥

case′_[zero⇒_|suc_⇒_] : Term → Term → Term → Term → Term
case′ L [zero⇒ M |suc (` x) ⇒ N ]  =  case L [zero⇒ M |suc x ⇒ N ]
case′ _ [zero⇒ _ |suc _ ⇒ _ ]      =  ⊥-elim impossible
  where postulate impossible : ⊥

μ′_⇒_ : Term → Term → Term
μ′ (` x) ⇒ N  =  μ x ⇒ N
μ′ _ ⇒ _      =  ⊥-elim impossible
  where postulate impossible : ⊥
-Agda-}

-- TODO

{-Agda-
plus′ : Term
plus′ = μ′ + ⇒ ƛ′ m ⇒ ƛ′ n ⇒
          case′ m
            [zero⇒ n
            |suc m ⇒ `suc (+ · m · n) ]
  where
  +  =  ` "+"
  m  =  ` "m"
  n  =  ` "n"
-Agda-}

-- TODO

{-Agda-
data Value : Term → Set where

  V-ƛ : ∀ {x N}
      ---------------
    → Value (ƛ x ⇒ N)

  V-zero :
      -----------
      Value `zero

  V-suc : ∀ {V}
    → Value V
      --------------
    → Value (`suc V)
-Agda-}

\data Value (t : Term) \with
  | lam x N => V-lam
  | zero' => V-zero'
  | suc' V => V-suc' (Value V)

{-Agda-
infix 9 _[_:=_]

_[_:=_] : Term → Id → Term → Term
(` x) [ y := V ] with x ≟ y
... | yes _          =  V
... | no  _          =  ` x
(ƛ x ⇒ N) [ y := V ] with x ≟ y
... | yes _          =  ƛ x ⇒ N
... | no  _          =  ƛ x ⇒ N [ y := V ]
(L · M) [ y := V ]   =  L [ y := V ] · M [ y := V ]
(`zero) [ y := V ]   =  `zero
(`suc M) [ y := V ]  =  `suc M [ y := V ]
(case L [zero⇒ M |suc x ⇒ N ]) [ y := V ] with x ≟ y
... | yes _          =  case L [ y := V ] [zero⇒ M [ y := V ] |suc x ⇒ N ]
... | no  _          =  case L [ y := V ] [zero⇒ M [ y := V ] |suc x ⇒ N [ y := V ] ]
(μ x ⇒ N) [ y := V ] with x ≟ y
... | yes _          =  μ x ⇒ N
... | no  _          =  μ x ⇒ N [ y := V ]
-Agda-}

\func subst \alias \infix 9 <<= (N : Term) (s : \Sigma Id Term) : Term
  | ref x, (y, V) => \case decideEq x y \with {
    | yes _ => V
    | no _ => ref x
  }
  | lam x N, (y, V) => \case decideEq x y \with {
    | yes _ => lam x N
    | no _ => lam x $ N <<= (y, V)
  }
  | ∙ L M, (y, V) => L <<= (y, V) ∙ M <<= (y, V)
  | zero', (y, V) => zero'
  | suc' M, (y, V) => suc' $ M <<= (y, V)
  | case L M x N, (y, V) => \case decideEq x y \with {
    | yes _ => case (L <<= (y, V)) (M <<= (y, V)) x N
    | no _ => case (L <<= (y, V)) (M <<= (y, V)) x (N <<= (y, V))
  }
  | fixpoint x N, (y, V) => \case decideEq x y \with {
    | yes _ => fixpoint x N
    | no _ => fixpoint x $ N <<= (y, V)
  }

{-Agda-
_ : (ƛ "z" ⇒ ` "s" · (` "s" · ` "z")) [ "s" := sucᶜ ] ≡ ƛ "z" ⇒ sucᶜ · (sucᶜ · ` "z")
_ = refl

_ : (sucᶜ · (sucᶜ · ` "z")) [ "z" := `zero ] ≡ sucᶜ · (sucᶜ · `zero)
_ = refl

_ : (ƛ "x" ⇒ ` "y") [ "y" := `zero ] ≡ ƛ "x" ⇒ `zero
_ = refl

_ : (ƛ "x" ⇒ ` "x") [ "x" := `zero ] ≡ ƛ "x" ⇒ ` "x"
_ = refl

_ : (ƛ "y" ⇒ ` "y") [ "x" := `zero ] ≡ ƛ "y" ⇒ ` "y"
_ = refl
-Agda-}

\func example-subst1 : lam Z (ref S ∙ (ref S ∙ ref Z)) <<= (S, suc-c) = lam Z (suc-c ∙ (suc-c ∙ ref Z)) => idp

\func example-subst2 : suc-c ∙ (suc-c ∙ ref Z) <<= (Z, zero') = suc-c ∙ (suc-c ∙ zero') => idp

\func example-subst3 : lam X (ref Y) <<= (Y, zero') = lam X zero' => idp

\func example-subst4 : lam X (ref X) <<= (X, zero') = lam X (ref X) => idp

\func example-subst5 : lam Y (ref Y) <<= (X, zero') = lam Y (ref Y) => idp

{-Agda-
-- Your code goes here
-Agda-}

\module subst-refactoring \where {
  \func subst \alias \infix 9 <<= (N : Term) (s : \Sigma Id Term) : Term
    | ref x, (y, V) => \case decideEq x y \with {
      | yes _ => V
      | no _ => ref x
    }
    | lam x N, (y, V) => lam x $ N <<=-≠ (x, y, V)
    | ∙ L M, (y, V) => L <<= (y, V) ∙ M <<= (y, V)
    | zero', (y, V) => zero'
    | suc' M, (y, V) => suc' $ M <<= (y, V)
    | case L M x N, (y, V) => case (L <<= (y, V)) (M <<= (y, V)) x (N <<=-≠ (x, y, V))
    | fixpoint x N, (y, V) => fixpoint x $ N <<=-≠ (x, y, V)

  \func subst-if-not-equal \alias \infix 9 <<=-≠ (N : Term) (s : \Sigma Id Id Term) : Term \elim s
    | (x, y, V) => \case decideEq x y \with {
      | yes _ => N
      | no _ => N <<= (y, V)
    }
}