{-Agda-
open import Data.Bool using (T; not)
open import Data.Empty using (⊥; ⊥-elim)
open import Data.List using (List; _∷_; [])
open import Data.Nat using (ℕ; zero; suc)
open import Data.Product using (∃-syntax; _×_)
open import Data.String using (String; _≟_)
open import Relation.Nullary using (Dec; yes; no; ¬_)
open import Relation.Nullary.Decidable using (⌊_⌋; False; toWitnessFalse)
open import Relation.Nullary.Negation using (¬?)
open import Relation.Binary.PropositionalEquality using (_≡_; _≢_; refl)
-Agda-}

{-Agda-
Id : Set
Id = String

infix  5  ƛ_⇒_
infix  5  μ_⇒_
infixl 7  _·_
infix  8  `suc_
infix  9  `_

data Term : Set where
  `_                      :  Id → Term
  ƛ_⇒_                    :  Id → Term → Term
  _·_                     :  Term → Term → Term
  `zero                   :  Term
  `suc_                   :  Term → Term
  case_[zero⇒_|suc_⇒_]    :  Term → Term → Id → Term → Term
  μ_⇒_                    :  Id → Term → Term
-Agda-}

-- There is no String data type in Arend, so we will use natural numbers as identifiers.

\func Id => Nat

-- Here we import all identifiers that will be used in this chapter.

\import util.LambdaIdentifiers

\data Term
  | ref Id
  | lam Id Term
  | \infixl 7 o' Term Term
  | zero'
  | suc' Term
  | case (num : Term) (tzeroCase : Term) (tsucId : Id) (tsucCase : Term)
  | fixpoint Id Term

{-Agda-
two : Term
two = `suc `suc `zero

plus : Term
plus = μ "+" ⇒ ƛ "m" ⇒ ƛ "n" ⇒
         case ` "m"
           [zero⇒ ` "n"
           |suc "m" ⇒ `suc (` "+" · ` "m" · ` "n") ]
 -}

\func two => suc' (suc' zero')

\func plus => fixpoint PLUS (lam M (lam N
    (case (ref M)
        (ref N)
        M (suc' (ref PLUS o' ref M o' ref N))
    )
))

{-Agda-
twoᶜ : Term
twoᶜ =  ƛ "s" ⇒ ƛ "z" ⇒ ` "s" · (` "s" · ` "z")

plusᶜ : Term
plusᶜ =  ƛ "m" ⇒ ƛ "n" ⇒ ƛ "s" ⇒ ƛ "z" ⇒
         ` "m" · ` "s" · (` "n" · ` "s" · ` "z")

sucᶜ : Term
sucᶜ = ƛ "n" ⇒ `suc (` "n")
 -}

\func two-c => lam S (lam Z (ref S o' (ref S o' ref Z)))

\func plus-c => lam M (lam N (lam S (lam Z (ref M o' ref S o' (ref N o' ref S o' ref Z)))))

\func suc-c => lam N (suc' (ref N))